diff --git a/mailnews/base/search/src/nsMsgSearchAdapter.cpp b/mailnews/base/search/src/nsMsgSearchAdapter.cpp
--- a/mailnews/base/search/src/nsMsgSearchAdapter.cpp
+++ b/mailnews/base/search/src/nsMsgSearchAdapter.cpp
@@ -683,17 +683,17 @@ nsresult nsMsgSearchAdapter::EncodeImapV
   }
 
   if (!NS_IsAscii(value))
   {
     nsCAutoString lengthStr;
     PL_strcat(encoding, "{");
     lengthStr.AppendInt((PRInt32) strlen(value));
     PL_strcat(encoding, lengthStr.get());
-    PL_strcat(encoding, "}"CRLF);
+    PL_strcat(encoding, "}" CRLF);
     PL_strcat(encoding, value);
     return NS_OK;
   }
   if (useQuotes)
     PL_strcat(encoding, "\"");
   PL_strcat (encoding, value);
   if (useQuotes)
     PL_strcat(encoding, "\"");
diff --git a/mailnews/base/src/nsMsgFolderCompactor.cpp b/mailnews/base/src/nsMsgFolderCompactor.cpp
--- a/mailnews/base/src/nsMsgFolderCompactor.cpp
+++ b/mailnews/base/src/nsMsgFolderCompactor.cpp
@@ -753,17 +753,17 @@ nsFolderCompactState::OnDataAvailable(ns
           m_folder->GetMsgDatabase(getter_AddRefs(srcDB));
           if (srcDB)
           {
             srcDB->SetSummaryValid(false);
             srcDB->ForceClosed();
           }
         }
       }
-#define EXTRA_KEYWORD_HDR "                                                                                 "MSG_LINEBREAK
+#define EXTRA_KEYWORD_HDR "                                                                                 " MSG_LINEBREAK
 
        // if status offset isn't in the first block, this code won't work. There's no good reason
       // for the status offset not to be at the beginning of the message anyway.
       if (addKeywordHdr)
       {
         // if blockOffset is set, we added x-mozilla-status headers so
         // file pointer is already past them.
         if (!blockOffset)
@@ -1211,17 +1211,17 @@ nsOfflineStoreCompactState::OnDataAvaila
     if (NS_SUCCEEDED(rv))
     {
       if (m_startOfMsg)
       {
         m_startOfMsg = false;
         // check if there's an envelope header; if not, write one.
         if (strncmp(m_dataBuffer, "From ", 5))
         {
-          m_fileStream->Write("From "CRLF, 7, &bytesWritten);
+          m_fileStream->Write("From " CRLF, 7, &bytesWritten);
           m_offlineMsgSize += bytesWritten;
         }
       }
       m_fileStream->Write(m_dataBuffer, readCount, &bytesWritten);
       m_offlineMsgSize += bytesWritten;
       writeCount += bytesWritten;
       count -= readCount;
       if (writeCount != readCount)
diff --git a/mailnews/compose/src/nsSmtpProtocol.cpp b/mailnews/compose/src/nsSmtpProtocol.cpp
--- a/mailnews/compose/src/nsSmtpProtocol.cpp
+++ b/mailnews/compose/src/nsSmtpProtocol.cpp
@@ -1705,17 +1705,17 @@ PRInt32 nsSmtpProtocol::SendMessageRespo
 
   /* else */
   return SendQuit();
 }
 
 PRInt32 nsSmtpProtocol::SendQuit()
 {
   m_sendDone = true;
-  SendData("QUIT"CRLF); // send a quit command to close the connection with the server.
+  SendData("QUIT" CRLF); // send a quit command to close the connection with the server.
   m_nextState = SMTP_RESPONSE;
   m_nextStateAfterResponse = SMTP_DONE;
   return(0);
 }
 
 nsresult nsSmtpProtocol::LoadUrl(nsIURI * aURL, nsISupports * aConsumer )
 {
   if (!aURL)
@@ -1951,17 +1951,17 @@ nsresult nsSmtpProtocol::LoadUrl(nsIURI 
     }
 
     /* check for errors during load and call error
     * state if found
     */
     if(status < 0 && m_nextState != SMTP_FREE)
     {
       // send a quit command to close the connection with the server.
-      if (SendData("QUIT"CRLF) == NS_OK)
+      if (SendData("QUIT" CRLF) == NS_OK)
       {
         m_nextState = SMTP_RESPONSE;
         m_nextStateAfterResponse = SMTP_ERROR_DONE;
       }
       else
       {
       m_nextState = SMTP_ERROR_DONE;
       /* don't exit! loop around again and do the free case */
diff --git a/mailnews/imap/src/nsImapMailFolder.cpp b/mailnews/imap/src/nsImapMailFolder.cpp
--- a/mailnews/imap/src/nsImapMailFolder.cpp
+++ b/mailnews/imap/src/nsImapMailFolder.cpp
@@ -8300,17 +8300,17 @@ nsImapMailFolder::CopyFileToOfflineStore
           srcFile->GetFileSize(&fileSize);
           PRUint32 bytesWritten;
           rv = NS_OK;
           msgParser->SetState(nsIMsgParseMailMsgState::ParseHeadersState);
           msgParser->SetNewMsgHdr(fakeHdr);
           bool needMoreData = false;
           char * newLine = nsnull;
           PRUint32 numBytesInLine = 0;
-          const char *envelope = "From "CRLF;
+          const char *envelope = "From " CRLF;
           offlineStore->Write(envelope, strlen(envelope), &bytesWritten);
           fileSize += bytesWritten;
           do
           {
             newLine = inputStreamBuffer->ReadNextLine(inputStream, numBytesInLine, needMoreData);
             if (newLine)
             {
               msgParser->ParseAFolderLine(newLine, numBytesInLine);
diff --git a/mailnews/imap/src/nsImapProtocol.cpp b/mailnews/imap/src/nsImapProtocol.cpp
--- a/mailnews/imap/src/nsImapProtocol.cpp
+++ b/mailnews/imap/src/nsImapProtocol.cpp
@@ -1404,17 +1404,17 @@ nsImapProtocol::ImapThreadMainLoop()
 
   PR_LOG(IMAP, PR_LOG_DEBUG, ("ImapThreadMainLoop leaving [this=%x]\n", this));
 }
 
 void nsImapProtocol::HandleIdleResponses()
 {
   // PRInt32 oldRecent = GetServerStateParser().NumberOfRecentMessages();
   nsCAutoString commandBuffer(GetServerCommandTag());
-  commandBuffer.Append(" IDLE"CRLF);
+  commandBuffer.Append(" IDLE" CRLF);
 
   do
   {
     ParseIMAPandCheckForNewMail(commandBuffer.get());
   }
   while (m_inputStreamBuffer->NextLineAvailable() && GetServerStateParser().Connected());
 
   //  if (oldRecent != GetServerStateParser().NumberOfRecentMessages())
@@ -3284,17 +3284,17 @@ void nsImapProtocol::FetchMsgAttribute(c
 {
     IncrementCommandTagNumber();
 
     nsCAutoString commandString (GetServerCommandTag());
     commandString.Append(" UID fetch ");
     commandString.Append(messageIds);
     commandString.Append(" (");
     commandString.Append(attribute);
-    commandString.Append(")"CRLF);
+    commandString.Append(")" CRLF);
     nsresult rv = SendData(commandString.get());
 
     if (NS_SUCCEEDED(rv))
        ParseIMAPandCheckForNewMail(commandString.get());
     GetServerStateParser().SetFetchingFlags(false);
     GetServerStateParser().SetFetchingEverythingRFC822(false); // always clear this flag after every fetch....
 }
 
@@ -5280,17 +5280,17 @@ nsImapProtocol::Expunge()
       delete search;
       if (key == 0)
         return;  //no deleted messages to expunge (bug 235004)
     }
   }
 
   IncrementCommandTagNumber();
   nsCAutoString command(GetServerCommandTag());
-  command.Append(" expunge"CRLF);
+  command.Append(" expunge" CRLF);
 
   nsresult rv = SendData(command.get());
   if (NS_SUCCEEDED(rv))
     ParseIMAPandCheckForNewMail();
 }
 
 void
 nsImapProtocol::HandleMemoryFailure()
@@ -5356,17 +5356,17 @@ void nsImapProtocol::ID()
   if (!gAppName[0])
     return;
   IncrementCommandTagNumber();
   nsCString command(GetServerCommandTag());
   command.Append(" ID (\"name\" \"");
   command.Append(gAppName);
   command.Append("\" \"version\" \"");
   command.Append(gAppVersion);
-  command.Append("\")"CRLF);
+  command.Append("\")" CRLF);
 
   nsresult rv = SendData(command.get());
   if (NS_SUCCEEDED(rv))
     ParseIMAPandCheckForNewMail();
 }
 
 void nsImapProtocol::EnableCondStore()
 {
@@ -5813,17 +5813,17 @@ nsresult nsImapProtocol::AuthLogin(const
     command.Append(escapedUserName);
     command.Append("\" \"");
 
     // if the password contains a \, login will fail
     // turn foo\bar into foo\\bar
     nsCAutoString correctedPassword;
     EscapeUserNamePasswordString(password.get(), &correctedPassword);
     command.Append(correctedPassword);
-    command.Append("\""CRLF);
+    command.Append("\"" CRLF);
     rv = SendData(command.get(), true /* suppress logging */);
     NS_ENSURE_SUCCESS(rv, rv);
     ParseIMAPandCheckForNewMail();
   }
   else if (flag & kHasAuthNoneCapability)
   {
     // TODO What to do? "login <username>" like POP?
     return NS_ERROR_NOT_IMPLEMENTED;
@@ -7453,17 +7453,17 @@ void nsImapProtocol::CreateMailbox(const
 
   IncrementCommandTagNumber();
 
   nsCString escapedName;
   CreateEscapedMailboxName(mailboxName, escapedName);
   nsCString command(GetServerCommandTag());
   command += " create \"";
   command += escapedName;
-  command += "\""CRLF;
+  command += "\"" CRLF;
 
   nsresult rv = SendData(command.get());
   if(NS_SUCCEEDED(rv))
     ParseIMAPandCheckForNewMail();
   // If that failed, let's list the parent folder to see if
   // it allows inferiors, so we won't try to create sub-folders
   // of the parent folder again in the current session.
   if (GetServerStateParser().CommandFailed())
@@ -7556,17 +7556,17 @@ void nsImapProtocol::Lsub(const char *ma
   nsCString escapedPattern;
   CreateEscapedMailboxName(boxnameWithOnlineDirectory ?
                         boxnameWithOnlineDirectory :
                         mailboxPattern, escapedPattern);
 
   nsCString command (GetServerCommandTag());
   command += " lsub \"\" \"";
   command += escapedPattern;
-  command += "\""CRLF;
+  command += "\"" CRLF;
 
   PR_Free(boxnameWithOnlineDirectory);
 
   nsresult rv = SendData(command.get());
   if (NS_SUCCEEDED(rv))
     ParseIMAPandCheckForNewMail();
 }
 
@@ -7585,17 +7585,17 @@ void nsImapProtocol::List(const char *ma
   CreateEscapedMailboxName(boxnameWithOnlineDirectory ?
                         boxnameWithOnlineDirectory :
                         mailboxPattern, escapedPattern);
 
   nsCString command (GetServerCommandTag());
   command += useXLIST ?
     " xlist \"\" \"" : " list \"\" \"";
   command += escapedPattern;
-  command += "\""CRLF;
+  command += "\"" CRLF;
 
   PR_Free(boxnameWithOnlineDirectory);
 
   nsresult rv = SendData(command.get());
   if (NS_SUCCEEDED(rv))
     ParseIMAPandCheckForNewMail(command.get(), true);
 }
 
@@ -7606,17 +7606,17 @@ void nsImapProtocol::Subscribe(const cha
   IncrementCommandTagNumber();
 
   nsCString escapedName;
   CreateEscapedMailboxName(mailboxName, escapedName);
 
   nsCString command (GetServerCommandTag());
   command += " subscribe \"";
   command += escapedName;
-  command += "\""CRLF;
+  command += "\"" CRLF;
 
   nsresult rv = SendData(command.get());
   if (NS_SUCCEEDED(rv))
     ParseIMAPandCheckForNewMail();
 }
 
 void nsImapProtocol::Unsubscribe(const char *mailboxName)
 {
@@ -7624,31 +7624,31 @@ void nsImapProtocol::Unsubscribe(const c
   IncrementCommandTagNumber();
 
   nsCString escapedName;
   CreateEscapedMailboxName(mailboxName, escapedName);
 
   nsCString command (GetServerCommandTag());
   command += " unsubscribe \"";
   command += escapedName;
-  command += "\""CRLF;
+  command += "\"" CRLF;
 
   nsresult rv = SendData(command.get());
   if (NS_SUCCEEDED(rv))
       ParseIMAPandCheckForNewMail();
 }
 
 void nsImapProtocol::Idle()
 {
   IncrementCommandTagNumber();
 
   if (m_urlInProgress)
     return;
   nsCAutoString command (GetServerCommandTag());
-  command += " IDLE"CRLF;
+  command += " IDLE" CRLF;
   nsresult rv = SendData(command.get());
   if (NS_SUCCEEDED(rv))
   {
       m_idle = true;
       // we'll just get back a continuation char at first.
       // + idling...
       ParseIMAPandCheckForNewMail();
       // this will cause us to get notified of data or the socket getting closed.
@@ -7665,17 +7665,17 @@ void nsImapProtocol::Idle()
 // responses, we need to not wait for the server response
 // on shutdown.
 void nsImapProtocol::EndIdle(bool waitForResponse /* = true */)
 {
   // clear the async wait - otherwise, we seem to have trouble doing a blocking read
   nsCOMPtr <nsIAsyncInputStream> asyncInputStream = do_QueryInterface(m_inputStream);
   if (asyncInputStream)
     asyncInputStream->AsyncWait(nsnull, 0, 0, nsnull);
-  nsresult rv = SendData("DONE"CRLF);
+  nsresult rv = SendData("DONE" CRLF);
   // set a short timeout if we don't want to wait for a response
   if (m_transport && !waitForResponse)
     m_transport->SetTimeout(nsISocketTransport::TIMEOUT_READ_WRITE, 5);
   if (NS_SUCCEEDED(rv))
   {
     m_idle = false;
     ParseIMAPandCheckForNewMail();
   }
@@ -7734,18 +7734,18 @@ void nsImapProtocol::Copy(const char * m
   nsTArray<nsMsgKey> msgKeys;
   if (idsAreUid)
     ParseUidString(messageList, msgKeys);
 
   PRInt32 msgCountLeft = msgKeys.Length();
   PRUint32 msgsHandled = 0;
   const char *formatString;
   formatString = (idsAreUid)
-      ? "%s uid store %s %s"CRLF
-      : "%s store %s %s"CRLF;
+      ? "%s uid store %s %s" CRLF
+      : "%s store %s %s" CRLF;
 
   do
   {
     nsCString idString;
 
     PRUint32 msgsToHandle = msgCountLeft;
     if (idsAreUid)
       AllocateImapUidString(msgKeys.Elements() + msgsHandled, msgsToHandle, m_flagState, idString);
diff --git a/mailnews/imap/src/nsImapServerResponseParser.cpp b/mailnews/imap/src/nsImapServerResponseParser.cpp
--- a/mailnews/imap/src/nsImapServerResponseParser.cpp
+++ b/mailnews/imap/src/nsImapServerResponseParser.cpp
@@ -180,17 +180,17 @@ void nsImapServerResponseParser::Initial
 //           continue-req    = "+" SP (resp-text / base64) CRLF
 void nsImapServerResponseParser::ParseIMAPServerResponse(const char *aCurrentCommand,
                                                          bool aIgnoreBadAndNOResponses,
                                                          char *aGreetingWithCapability)
 {
   
   NS_ASSERTION(aCurrentCommand && *aCurrentCommand != '\r' && 
     *aCurrentCommand != '\n' && *aCurrentCommand != ' ', "Invailid command string");
-  bool sendingIdleDone = !strcmp(aCurrentCommand, "DONE"CRLF);
+  bool sendingIdleDone = !strcmp(aCurrentCommand, "DONE" CRLF);
   if (sendingIdleDone)
     fWaitingForMoreClientInput = false;
 
   // Reinitialize the parser
   SetConnected(true);
   SetSyntaxError(false);
   
   // Reinitialize our state
diff --git a/mailnews/local/src/nsPop3Protocol.cpp b/mailnews/local/src/nsPop3Protocol.cpp
--- a/mailnews/local/src/nsPop3Protocol.cpp
+++ b/mailnews/local/src/nsPop3Protocol.cpp
@@ -2480,17 +2480,17 @@ PRInt32 nsPop3Protocol::SendList()
 
 
     m_pop3ConData->msg_info = (Pop3MsgInfo *)
       PR_CALLOC(sizeof(Pop3MsgInfo) * m_pop3ConData->number_of_messages);
     if (!m_pop3ConData->msg_info)
         return(MK_OUT_OF_MEMORY);
     m_pop3ConData->next_state_after_response = POP3_GET_LIST;
     m_listpos = 0;
-    return SendData("LIST"CRLF);
+    return SendData("LIST" CRLF);
 }
 
 
 
 PRInt32
 nsPop3Protocol::GetList(nsIInputStream* inputStream,
                         PRUint32 length)
 {
diff --git a/mailnews/mime/src/mimedrft.cpp b/mailnews/mime/src/mimedrft.cpp
--- a/mailnews/mime/src/mimedrft.cpp
+++ b/mailnews/mime/src/mimedrft.cpp
@@ -1468,17 +1468,17 @@ mime_parse_stream_complete (nsMIMESessio
                //+13 chars for <pre> & </pre> tags and CRLF
               PRUint32 newbodylen = bodyLen + 14;
               char* newbody = (char *)PR_MALLOC (newbodylen);
               if (newbody)
               {
                 *newbody = 0;
                 PL_strcatn(newbody, newbodylen, "<PRE>");
                 PL_strcatn(newbody, newbodylen, body);
-                PL_strcatn(newbody, newbodylen, "</PRE>"CRLF);
+                PL_strcatn(newbody, newbodylen, "</PRE>" CRLF);
                 PR_Free(body);
                 body = newbody;
               }
             }
             // Body is now HTML, set the format too (so headers are inserted in
             // correct format).
             composeFormat = nsIMsgCompFormat::HTML;
           }
diff --git a/mailnews/mime/src/mimemult.cpp b/mailnews/mime/src/mimemult.cpp
--- a/mailnews/mime/src/mimemult.cpp
+++ b/mailnews/mime/src/mimemult.cpp
@@ -275,44 +275,44 @@ MimeMultipart_parse_line (const char *li
             {
               MimeWriteAString(obj, NS_LITERAL_CSTRING("Content-Type: "));
               MimeWriteAString(obj, nsDependentCString(contentType));
               PR_Free(contentType);
             }
             MimeWriteAString(obj, NS_LITERAL_CSTRING(MSG_LINEBREAK));
             MimeWriteAString(obj, NS_LITERAL_CSTRING("Content-Disposition: attachment; filename=\""));
             MimeWriteAString(obj, fileName);
-            MimeWriteAString(obj, NS_LITERAL_CSTRING("\""MSG_LINEBREAK));
+            MimeWriteAString(obj, NS_LITERAL_CSTRING("\"" MSG_LINEBREAK));
             MimeWriteAString(obj, NS_LITERAL_CSTRING("X-Mozilla-External-Attachment-URL: "));
             MimeWriteAString(obj, obj->options->state->detachedFilePath);
             MimeWriteAString(obj, NS_LITERAL_CSTRING(MSG_LINEBREAK));
             MimeWriteAString(obj, NS_LITERAL_CSTRING("X-Mozilla-Altered: AttachmentDetached; date=\""));
           }
           else
           {
             nsCAutoString header("Content-Type: text/x-moz-deleted; name=\"Deleted: ");
             header.Append(fileName);
             status = MimeWriteAString(obj, header);
             if (status < 0) 
               return status;
-            status = MimeWriteAString(obj, NS_LITERAL_CSTRING("\""MSG_LINEBREAK"Content-Transfer-Encoding: 8bit"MSG_LINEBREAK));
+            status = MimeWriteAString(obj, NS_LITERAL_CSTRING("\"" MSG_LINEBREAK "Content-Transfer-Encoding: 8bit" MSG_LINEBREAK));
             MimeWriteAString(obj, NS_LITERAL_CSTRING("Content-Disposition: inline; filename=\"Deleted: "));
             MimeWriteAString(obj, fileName);
-            MimeWriteAString(obj, NS_LITERAL_CSTRING("\""MSG_LINEBREAK"X-Mozilla-Altered: AttachmentDeleted; date=\""));
+            MimeWriteAString(obj, NS_LITERAL_CSTRING("\"" MSG_LINEBREAK "X-Mozilla-Altered: AttachmentDeleted; date=\""));
           }
           nsCString result;
           char timeBuffer[128];
           PRExplodedTime now;
           PR_ExplodeTime(PR_Now(), PR_LocalTimeParameters, &now);
           PR_FormatTimeUSEnglish(timeBuffer, sizeof(timeBuffer),
                                  "%a %b %d %H:%M:%S %Y",
                                  &now);
           MimeWriteAString(obj, nsDependentCString(timeBuffer));
-          MimeWriteAString(obj, NS_LITERAL_CSTRING("\""MSG_LINEBREAK));
-          MimeWriteAString(obj, NS_LITERAL_CSTRING(MSG_LINEBREAK"You deleted an attachment from this message. The original MIME headers for the attachment were:"MSG_LINEBREAK));
+          MimeWriteAString(obj, NS_LITERAL_CSTRING("\"" MSG_LINEBREAK));
+          MimeWriteAString(obj, NS_LITERAL_CSTRING(MSG_LINEBREAK "You deleted an attachment from this message. The original MIME headers for the attachment were:" MSG_LINEBREAK));
           MimeHeaders_write_raw_headers(mult->hdrs, obj->options, false);
         }
         PRInt32 old_nchildren = container->nchildren;
         status = ((MimeMultipartClass *) obj->clazz)->create_child(obj);
         if (status < 0) return status;
         NS_ASSERTION(mult->state != MimeMultipartHeaders,
                      "mult->state shouldn't be MimeMultipartHeaders");
 
