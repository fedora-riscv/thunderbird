changeset:   465480:a86f3560fb17
parent:      465477:26d9b7ffbd6b
user:        Martin Stransky <stransky@redhat.com>
date:        Fri Mar 29 15:30:15 2019 +0100
summary:     Bug 1526243 - [Linux] Don't use nsGConfService in nsGNOMEShellService.cpp, r=glandium

diff --git a/browser/components/shell/nsGNOMEShellService.cpp b/browser/components/shell/nsGNOMEShellService.cpp
--- a/browser/components/shell/nsGNOMEShellService.cpp
+++ b/browser/components/shell/nsGNOMEShellService.cpp
@@ -10,17 +10,16 @@
 #include "nsShellService.h"
 #include "nsIServiceManager.h"
 #include "nsIFile.h"
 #include "nsIProperties.h"
 #include "nsDirectoryServiceDefs.h"
 #include "nsIPrefService.h"
 #include "prenv.h"
 #include "nsString.h"
-#include "nsIGConfService.h"
 #include "nsIGIOService.h"
 #include "nsIGSettingsService.h"
 #include "nsIStringBundle.h"
 #include "nsIOutputStream.h"
 #include "nsIProcess.h"
 #include "nsServiceManagerUtils.h"
 #include "nsComponentManagerUtils.h"
 #include "nsIImageLoadingContent.h"
@@ -65,48 +64,39 @@ static const ProtocolAssociation appProt
 
 static const MimeTypeAssociation appTypes[] = {
     // clang-format off
   { "text/html",             "htm html shtml" },
   { "application/xhtml+xml", "xhtml xht"      }
     // clang-format on
 };
 
-// GConf registry key constants
-#define DG_BACKGROUND "/desktop/gnome/background"
-
-#define kDesktopImageKey DG_BACKGROUND "/picture_filename"
-#define kDesktopOptionsKey DG_BACKGROUND "/picture_options"
-#define kDesktopDrawBGKey DG_BACKGROUND "/draw_background"
-#define kDesktopColorKey DG_BACKGROUND "/primary_color"
-
 #define kDesktopBGSchema "org.gnome.desktop.background"
 #define kDesktopImageGSKey "picture-uri"
 #define kDesktopOptionGSKey "picture-options"
 #define kDesktopDrawBGGSKey "draw-background"
 #define kDesktopColorGSKey "primary-color"
 
 static bool IsRunningAsASnap() { return (PR_GetEnv("SNAP") != nullptr); }
 
 nsresult nsGNOMEShellService::Init() {
   nsresult rv;
 
   if (gfxPlatform::IsHeadless()) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
-  // GConf, GSettings or GIO _must_ be available, or we do not allow
+  // GSettings or GIO _must_ be available, or we do not allow
   // CreateInstance to succeed.
 
-  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   nsCOMPtr<nsIGSettingsService> gsettings =
       do_GetService(NS_GSETTINGSSERVICE_CONTRACTID);
 
-  if (!gconf && !giovfs && !gsettings) return NS_ERROR_NOT_AVAILABLE;
+  if (!giovfs && !gsettings) return NS_ERROR_NOT_AVAILABLE;
 
   // Check G_BROKEN_FILENAMES.  If it's set, then filenames in glib use
   // the locale encoding.  If it's not set, they use UTF-8.
   mUseLocaleFilenames = PR_GetEnv("G_BROKEN_FILENAMES") != nullptr;
 
   if (GetAppPathFromLauncher()) return NS_OK;
 
   nsCOMPtr<nsIProperties> dirSvc(
@@ -212,35 +202,23 @@ nsGNOMEShellService::IsDefaultBrowser(bo
     }
     if (strcmp(output, "yes\n") == 0) {
       *aIsDefaultBrowser = true;
     }
     g_free(output);
     return NS_OK;
   }
 
-  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
-
-  bool enabled;
   nsAutoCString handler;
   nsCOMPtr<nsIGIOMimeApp> gioApp;
 
   for (unsigned int i = 0; i < ArrayLength(appProtocols); ++i) {
     if (!appProtocols[i].essential) continue;
 
-    if (gconf) {
-      handler.Truncate();
-      gconf->GetAppForProtocol(nsDependentCString(appProtocols[i].name),
-                               &enabled, handler);
-
-      if (!CheckHandlerMatchesAppName(handler) || !enabled)
-        return NS_OK;  // the handler is disabled or set to another app
-    }
-
     if (giovfs) {
       handler.Truncate();
       nsCOMPtr<nsIHandlerApp> handlerApp;
       giovfs->GetAppForURIScheme(nsDependentCString(appProtocols[i].name),
                                  getter_AddRefs(handlerApp));
       gioApp = do_QueryInterface(handlerApp);
       if (!gioApp) return NS_OK;
 
@@ -270,39 +248,17 @@ nsGNOMEShellService::SetDefaultBrowser(b
     GSpawnFlags flags = static_cast<GSpawnFlags>(G_SPAWN_SEARCH_PATH |
                                                  G_SPAWN_STDOUT_TO_DEV_NULL |
                                                  G_SPAWN_STDERR_TO_DEV_NULL);
     g_spawn_sync(nullptr, (gchar **)argv, nullptr, flags, nullptr, nullptr,
                  nullptr, nullptr, nullptr, nullptr);
     return NS_OK;
   }
 
-  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
-  if (gconf) {
-    nsAutoCString appKeyValue;
-    if (mAppIsInPath) {
-      // mAppPath is in the users path, so use only the basename as the launcher
-      gchar *tmp = g_path_get_basename(mAppPath.get());
-      appKeyValue = tmp;
-      g_free(tmp);
-    } else {
-      appKeyValue = mAppPath;
-    }
-
-    appKeyValue.AppendLiteral(" %s");
-
-    for (unsigned int i = 0; i < ArrayLength(appProtocols); ++i) {
-      if (appProtocols[i].essential || aClaimAllTypes) {
-        gconf->SetAppForProtocol(nsDependentCString(appProtocols[i].name),
-                                 appKeyValue);
-      }
-    }
-  }
-
   if (giovfs) {
     nsresult rv;
     nsCOMPtr<nsIStringBundleService> bundleService =
         do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsCOMPtr<nsIStringBundle> brandBundle;
     rv = bundleService->CreateBundle(BRAND_PROPERTIES,
@@ -353,19 +309,21 @@ nsGNOMEShellService::SetDefaultBrowser(b
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsGNOMEShellService::GetCanSetDesktopBackground(bool *aResult) {
   // setting desktop background is currently only supported
-  // for Gnome or desktops using the same GSettings and GConf keys
-  const char *gnomeSession = getenv("GNOME_DESKTOP_SESSION_ID");
-  if (gnomeSession) {
+  // for Gnome or desktops using the same GSettings keys
+  const char *currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+  if (currentDesktop &&
+      (strstr(currentDesktop, "GNOME-Flashback:GNOME") != nullptr ||
+       strstr(currentDesktop, "GNOME") != nullptr)) {
     *aResult = true;
   } else {
     *aResult = false;
   }
 
   return NS_OK;
 }
 
@@ -439,20 +397,16 @@ nsGNOMEShellService::SetDesktopBackgroun
   filePath.Append('/');
   filePath.Append(NS_ConvertUTF16toUTF8(brandName));
   filePath.AppendLiteral("_wallpaper.png");
 
   // write the image to a file in the home dir
   rv = WriteImage(filePath, container);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  // Try GSettings first. If we don't have GSettings or the right schema, fall
-  // back to using GConf instead. Note that if GSettings works ok, the changes
-  // get mirrored to GConf by the gsettings->gconf bridge in
-  // gnome-settings-daemon
   nsCOMPtr<nsIGSettingsService> gsettings =
       do_GetService(NS_GSETTINGSSERVICE_CONTRACTID);
   if (gsettings) {
     nsCOMPtr<nsIGSettingsCollection> background_settings;
     gsettings->GetCollectionForSchema(NS_LITERAL_CSTRING(kDesktopBGSchema),
                                       getter_AddRefs(background_settings));
     if (background_settings) {
       gchar *file_uri = g_filename_to_uri(filePath.get(), nullptr, nullptr);
@@ -465,32 +419,17 @@ nsGNOMEShellService::SetDesktopBackgroun
                                      nsDependentCString(file_uri));
       g_free(file_uri);
       background_settings->SetBoolean(NS_LITERAL_CSTRING(kDesktopDrawBGGSKey),
                                       true);
       return rv;
     }
   }
 
-  // if the file was written successfully, set it as the system wallpaper
-  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
-
-  if (gconf) {
-    gconf->SetString(NS_LITERAL_CSTRING(kDesktopOptionsKey), options);
-
-    // Set the image to an empty string first to force a refresh
-    // (since we could be writing a new image on top of an existing
-    // Firefox_wallpaper.png and nautilus doesn't monitor the file for changes)
-    gconf->SetString(NS_LITERAL_CSTRING(kDesktopImageKey), EmptyCString());
-
-    gconf->SetString(NS_LITERAL_CSTRING(kDesktopImageKey), filePath);
-    gconf->SetBool(NS_LITERAL_CSTRING(kDesktopDrawBGKey), true);
-  }
-
-  return rv;
+  return NS_ERROR_FAILURE;
 }
 
 #define COLOR_16_TO_8_BIT(_c) ((_c) >> 8)
 #define COLOR_8_TO_16_BIT(_c) ((_c) << 8 | (_c))
 
 NS_IMETHODIMP
 nsGNOMEShellService::GetDesktopBackgroundColor(uint32_t *aColor) {
   nsCOMPtr<nsIGSettingsService> gsettings =
@@ -502,22 +441,16 @@ nsGNOMEShellService::GetDesktopBackgroun
     gsettings->GetCollectionForSchema(NS_LITERAL_CSTRING(kDesktopBGSchema),
                                       getter_AddRefs(background_settings));
     if (background_settings) {
       background_settings->GetString(NS_LITERAL_CSTRING(kDesktopColorGSKey),
                                      background);
     }
   }
 
-  if (!background_settings) {
-    nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
-    if (gconf)
-      gconf->GetString(NS_LITERAL_CSTRING(kDesktopColorKey), background);
-  }
-
   if (background.IsEmpty()) {
     *aColor = 0;
     return NS_OK;
   }
 
   GdkColor color;
   gboolean success = gdk_color_parse(background.get(), &color);
 
@@ -555,23 +488,17 @@ nsGNOMEShellService::SetDesktopBackgroun
                                       getter_AddRefs(background_settings));
     if (background_settings) {
       background_settings->SetString(NS_LITERAL_CSTRING(kDesktopColorGSKey),
                                      colorString);
       return NS_OK;
     }
   }
 
-  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
-
-  if (gconf) {
-    gconf->SetString(NS_LITERAL_CSTRING(kDesktopColorKey), colorString);
-  }
-
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP
 nsGNOMEShellService::OpenApplication(int32_t aApplication) {
   nsAutoCString scheme;
   if (aApplication == APPLICATION_MAIL)
     scheme.AssignLiteral("mailto");
   else if (aApplication == APPLICATION_NEWS)
@@ -581,55 +508,17 @@ nsGNOMEShellService::OpenApplication(int
 
   nsCOMPtr<nsIGIOService> giovfs = do_GetService(NS_GIOSERVICE_CONTRACTID);
   if (giovfs) {
     nsCOMPtr<nsIHandlerApp> handlerApp;
     giovfs->GetAppForURIScheme(scheme, getter_AddRefs(handlerApp));
     if (handlerApp) return handlerApp->LaunchWithURI(nullptr, nullptr);
   }
 
-  nsCOMPtr<nsIGConfService> gconf = do_GetService(NS_GCONFSERVICE_CONTRACTID);
-  if (!gconf) return NS_ERROR_FAILURE;
-
-  bool enabled;
-  nsAutoCString appCommand;
-  gconf->GetAppForProtocol(scheme, &enabled, appCommand);
-
-  if (!enabled) return NS_ERROR_FAILURE;
-
-  // XXX we don't currently handle launching a terminal window.
-  // If the handler requires a terminal, bail.
-  bool requiresTerminal;
-  gconf->HandlerRequiresTerminal(scheme, &requiresTerminal);
-  if (requiresTerminal) return NS_ERROR_FAILURE;
-
-  // Perform shell argument expansion
-  int argc;
-  char **argv;
-  if (!g_shell_parse_argv(appCommand.get(), &argc, &argv, nullptr))
-    return NS_ERROR_FAILURE;
-
-  char **newArgv = new char *[argc + 1];
-  int newArgc = 0;
-
-  // Run through the list of arguments.  Copy all of them to the new
-  // argv except for %s, which we skip.
-  for (int i = 0; i < argc; ++i) {
-    if (strcmp(argv[i], "%s") != 0) newArgv[newArgc++] = argv[i];
-  }
-
-  newArgv[newArgc] = nullptr;
-
-  gboolean err = g_spawn_async(nullptr, newArgv, nullptr, G_SPAWN_SEARCH_PATH,
-                               nullptr, nullptr, nullptr, nullptr);
-
-  g_strfreev(argv);
-  delete[] newArgv;
-
-  return err ? NS_OK : NS_ERROR_FAILURE;
+  return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP
 nsGNOMEShellService::OpenApplicationWithURI(nsIFile *aApplication,
                                             const nsACString &aURI) {
   nsresult rv;
   nsCOMPtr<nsIProcess> process =
       do_CreateInstance("@mozilla.org/process/util;1", &rv);

