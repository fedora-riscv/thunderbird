diff --git a/mailnews/imap/src/nsImapIncomingServer.cpp b/mailnews/imap/src/nsImapIncomingServer.cpp
--- a/mailnews/imap/src/nsImapIncomingServer.cpp
+++ b/mailnews/imap/src/nsImapIncomingServer.cpp
@@ -2255,35 +2259,39 @@ nsImapIncomingServer::OnStopRunningUrl(n
       NS_ENSURE_SUCCESS(rv, rv);
       break;
     case nsIImapUrl::nsImapDiscoverAllBoxesUrl:
       if (NS_SUCCEEDED(exitCode))
         DiscoveryDone();
       break;
     case nsIImapUrl::nsImapFolderStatus:
     {
-      PRInt32 folderCount = m_foldersToStat.Count();
-      nsCOMPtr<nsIMsgFolder> msgFolder(
-          do_QueryInterface(m_foldersToStat[folderCount - 1]));
+      nsCOMPtr<nsIMsgFolder> msgFolder;
+      nsCOMPtr<nsIMsgMailNewsUrl> mailUrl = do_QueryInterface(imapUrl);
+      mailUrl->GetFolder(getter_AddRefs(msgFolder));
       if (msgFolder)
       {
         nsresult rv;
         nsCOMPtr<nsIMsgMailSession> session =
                  do_GetService(NS_MSGMAILSESSION_CONTRACTID, &rv);
         NS_ENSURE_SUCCESS(rv, rv);
         PRBool folderOpen;
         rv = session->IsFolderOpenInWindow(msgFolder, &folderOpen);
         if (NS_SUCCEEDED(rv) && !folderOpen && msgFolder)
           msgFolder->SetMsgDatabase(nsnull);
+        nsCOMPtr<nsIMsgImapMailFolder> imapFolder = do_QueryInterface(msgFolder);
+        m_foldersToStat.RemoveObject(imapFolder);
       }
-      m_foldersToStat.RemoveObjectAt(folderCount - 1);
-      // This should be done on a timeout, since we shouldn't start a new url
-      // from here.
-      if (folderCount > 1)
-        m_foldersToStat[folderCount - 2]->UpdateStatus(this, nsnull);
+      // if we get an error running the url, it's better
+      // not to chain the next url.
+      if (NS_FAILED(exitCode))
+        m_foldersToStat.Clear();
+      if (m_foldersToStat.Count() > 0)
+        m_foldersToStat[0]->UpdateStatus(this, nsnull);
+      break;
     }
     default:
         break;
     }
   }
   return NS_OK;
 }
 
@@ -2927,19 +2935,19 @@ nsImapIncomingServer::GetNewMessagesForN
       nsCOMPtr<nsIPrefBranch> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID);
       if(prefBranch)
         prefBranch->GetBoolPref("mail.imap.use_status_for_biff", &gUseStatus);
       gGotStatusPref = PR_TRUE;
     }
     if (gUseStatus && !isOpen)
     {
       nsCOMPtr <nsIMsgImapMailFolder> imapFolder = do_QueryInterface(aFolder);
-      if (imapFolder && !isServer)
+      if (imapFolder && !isServer &&
+          m_foldersToStat.IndexOf(imapFolder) == -1)
         m_foldersToStat.AppendObject(imapFolder);
-        //imapFolder->UpdateStatus(this, nsnull /* aWindow - null window will prevent alerts */);
     }
     else
       aFolder->UpdateFolder(aWindow);
   }
 
   // Loop through all subfolders to get new messages for them.
   nsCOMPtr<nsISimpleEnumerator> enumerator;
   nsresult rv = aFolder->GetSubFolders(getter_AddRefs(enumerator));
@@ -2956,23 +2964,18 @@ nsImapIncomingServer::GetNewMessagesForN
     if (!msgFolder)
     {
       NS_WARNING("Not an nsIMsgFolder");
       continue;
     }
     GetNewMessagesForNonInboxFolders(msgFolder, aWindow, forceAllFolders,
                                      performingBiff);
   }
-
-  if (isServer)
-  {
-    PRInt32 folderCount = m_foldersToStat.Count();
-    if (folderCount > 0)
-      m_foldersToStat[folderCount - 1]->UpdateStatus(this, nsnull);
-  }
+  if (isServer && m_foldersToStat.Count() > 0)
+    m_foldersToStat[0]->UpdateStatus(this, nsnull);
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsImapIncomingServer::GetArbitraryHeaders(nsACString &aResult)
 {
   nsCOMPtr <nsIMsgFilterList> filterList;
   nsresult rv = GetFilterList(nsnull, getter_AddRefs(filterList));
